三种表示 : 
$$
\Theta(g(n)) = \{ f(n) : there\space exist\space positive\space constants \space
                  c_1, c_2, and\space n_0\space such\space that \\0 ≤ c_1g(n) ≤
                  f(n) ≤ c_2g(n)\space for all\space n≥n0 \} \\
Example: 2n^3 + 150n^2-250n + 6024 = \Theta(n^3)
$$
$$
f(n) = O(g(n)) \space if \exist const\space c, n, such \space that \space 0 ≤ f(n) ≤ cg(n), \forall n≥n_0.\\
e.g. 2n^2 = O(n^3) (c=1, n_0=2)
$$

$$
\Omega(g(n)) = \{f(n): \exist const\space c, n_0\space such\space that\space 0 ≤ cg(n) ≤ f(n), \forall n≥n_0\} \\

    e.g. n½ = \Omega(lgn) (c=1, n_0=16)
$$

=> $(O\space and \space \Omega) <=> \Theta$

推荐一门stanford春季课程（要到月底开课）：http://web.stanford.edu/class/cs168/index.html

主定理：$T(n)=aT(n/b)+f(n)$

1. $f(n)=O(n^{log_ba-\epsilon})\to T(n)=O(n^{log_b a})$
2. $f(n)=\Theta(n^{log_ba}lg^kn)\to T(n)=\Theta(n^{log_b a}lg^{k+1}n)$
3. $f(n)=\Omega(n^{log_ba+\epsilon})\space and \space af(n/b) ≤cf(n) \to T(n)=\Theta(f(n))$, 常数c<1

主定理不适用地一个例子：

$T(n) = 4T(n/2)+n^2/lgn$

代入法 $T(n)=\Theta(n^2lglgn)$
$$
假设ck^2lglgk + c_1k^2lg(lg2k/lgk) ≤ T(k) ≤ c_2k^2lglgk+c_3k^2lglglgk，那么 \\
首先需要知道lgn/(lg(n/2)) ＞ lg(2n)/lgn\\
T(n) = 4T(n/2)+n^2/lgn≥4c(n^2/4)lglg(n/2)+c_1n^2lg(lgn/lg(n/2))+n^2/lgn \\
= cn^2lglgn+(c1-c)n^2lg(lgn/lg(n/2)) + n^2/lgn \\
≥ cn^2lglgn + c_1n^2lg(lg2n/lgn)\\ 

T(n) = 4T(n/2)+n^2/lgn≤4c_2(n^2/4)lglg(n/2)+c_3n^2lglglg(n/2) + n^2/lgn\\
≤c_2n^2lglg(n/2)+c_3n^2lglglg(n/2)+n^2/lgn\\
≤c_2n^2lglgn+c_3n^2lglglg(n)
$$
hash函数



证明$log(n!)=\Theta(nlogn)$

首先很容易知道$n!≤n^n$，所以$log(n!)=O(nlogn)$

然后需要证明$log(n!)=\Omega(nlogn)$

这时候我们需要一个性质：$n!≥(\frac{n}{2})^\frac{n}{2}$

简单可以理解一下，把n!的前一半扔掉就剩n/2···n，所以一定满足了

所以$log(n!)≥log(\frac{n}{2})^\frac{n}{2}=\frac{n}{2}log(\frac{n}{2})≥\frac{n}{2}logn^{1/2}=n/4logn,当n≥4时$

所以得证

#### 散列表

###### Cuckoo hashing

###### Bloom filter

###### Count_min sketch

数据流

###### Consistent hashing



#### 动态规划

###### 最长上升子序列：

定义 $dp[i]$ 为考虑前 $i$ 个元素，以第 $i$ 个数字结尾的最长上升子序列的长度

$dp[i] = max(dp[j]) + 1$，其中$0≤j＜i$且$nums[j]<nums[i]$

时间复杂度 $O(n^2)$

[贪心+二分查找](#https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)

###### 带权重的区间调度：

•Job *j* starts at $s_j$, finishes at $f_j$, and has weight or value $v_j$.

•Two jobs compatible if they don't overlap.

•Goal: find maximum weight subset of mutually compatible jobs.

###### 最长公共子序列：

Define *c*[*i*, *j*] = length of LCS of “prefixes” *x*[1..*i*] and *y*[1..*j*].

$dp[i,j]=\begin{cases} dp[i-1,j-1]+1& \text{if x[i]=y[j]}\\ max{dp[i,j-1],dp[i-1,j]}& \text{otherwise} \end{cases}$

###### 最长公共子串：

dp\[i][j]表示 str1[0…i] 与 str2[0…j] 的最长公共子串的长度。

计算dp\[i][j] 的方法如下：

1. 矩阵 dp 的第一列 dp\[0…m-1][0].对于 某个位置（i，0）如果str1[i]==str2[0],则dp\[i][0]=1,否则dp\[i][0]=0
2. 矩阵 dp 的第一行 dp\[0][0…n-1].对于 某个位置（0，j）如果str1[0]==str2[j],则dp\[0][j]=1,否则dp\[0][j]=0
3. 其他位置从左到右从上到下计算，dp\[i][j]的值只有两种情况：

1). str1[i]==str2[j],dp\[i][j]=dp\[i-1][j-1]+1;

2). str1[i]!=str2[j]则dp\[i][j]=0;

因为只需要左上角的值，那么可以优化空间复杂度到O(1)，遍历每一条对角线

###### 背包问题：

总容量为$W$，每件物品占$w_i$，价值$v_i$

第$i$件物品可以选择放入背包或者不放入背包

Let *V*(*k*,*B*) denote the value of the highest value solution that uses items from among the set {1, 2,…,*k*} and uses space at most *B*

则

$V[k,B]=\begin{cases}0&\text{if k = 0}\\ V[k-1,B]& \text{if s_k>B}\\ max{V[k-1,B-s_k]+v_k,V[k-1,B]}& \text{otherwise} \end{cases}$

###### 带权重的独立集问题：

找到无向图之间没有边的结点的最大集合

•Let *C*(*v*) be the set of children of vertex *v*.

•MIS(*u*) = Max-weight independent set of subtree hanging from *u*:

那么u可以选择放入或者不放入集合，如果不放入，那么就等于所有子节点为根节点的子树对应的MIS之和；如果放入，那么就是所有子节点的子节点为根节点的子树对应的MIS之和

$MIS(u) = max{\sum_{v \in C(u)} MIS(v), w_u + \sum_{v \in C(C(u)}MIS(v)}$

###### 旅行商问题：

For a subset of cities *S* $\in$ {1, 2,…,*n*} that includes 1, and *j* Î *S*, let *C*(*S*, *j*) be the length of the shortest path visiting each node in *S* exactly once, starting at 1 and ending at *j*

$C(s,j)=min_{i \in \{j\}}C\{S-\{j\},i\}+d_{ij}$

###### 矩阵链乘法：
