#### 前言

以下内容均来自崔添翼大佬的背包问题九讲，我只是为了加深印象重新写了一遍。

#### 1 0-1背包问题

###### 1.1 题目

有 $N$ 件物品和一个容量为 $V$ 的背包。放入第 $i$ 件物品耗费的费用是 $C_i$， 得到的价值是 $W_i$ 。求解将哪些物品装入背包可是价值总和最大。

###### 1.2 基本思路

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即 $F[i, v]$ 表示前 $i$ 件物品恰放入一个容量为 $v$ 的背包可以获得的最大价值。则其状态转移方程为：
$$
F[i,v]=max\{F[i-1,v],F[i-1,v-C_i] + W_i\}
$$
伪代码如下：

```C++
F[0,0..V ] ← 0 
for i ← 1 to N 
	for v ← Ci to V 
		F[i,v] ←max{F[i−1,v],F[i−1,v−Ci] + Wi} 
```

###### 1.3 优化空间复杂度

以上方法的时间和空间复杂度均为$O(VN)$，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到$O(V)$。

先考虑上面讲的思路如何实现，肯定是有一个主循环 $i ← 1 ... N$，每次算出来二维数组 $F[i,0 ... V]$ 的所有值。那么，如果只用一个数组 $F[0 ... V]$ ，能不能保证第 $i$ 次循环结束后 $F[v]$ 中表示的就是我们定义的状态 $F[i,v]$ 呢，$F[i,v]$ 是由 $F[i-1,v]$ 和 $F[i-1.v-C_i]$ 两个子问题递推而来，能否保证在推 $F[i,v]$ 时（也即在第 $i$ 次主循环中推 $F[v]$ 时）能够取用 $F[i-1,v]$ 和 $F[i-1,v-C_i]$ 的值呢。

事实上，这要求在每次主循环中我们以 $v ← V ... 0$ 的递减顺序计算 $F[v]$，这样才能保证计算 $F[v]$ 时 $F[v-C_i]$ 保存的是状态 $F[i-1,v-C_i]$ 的值。

```C++
F[0..V ]←0 
for i ← 1 to N 
	for v ← V to Ci 
		F[v] ←max{F[v],F[v−Ci] + Wi} 
```

###### 1.4 初始化的细节问题

我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求 “恰好装满背包” 时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。

如果是第一种问法，要求恰好装满背包，那么在初始化时除了 $F[0]$ 为0，其他 $F[1...V]$ 均为 -∞，这样就可以保证最终得到的 $F[V]$ 是一种恰好装满背包的最优解。

如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 $F[0 ... V]$ 全部设为 0 。

这是为什么呢？可以这样理解：初始化的 F 数组事实上就是在没有任何物品可以放 入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什 么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于 未定义的状态，应该被赋值为 -∞ 了。如果背包并非必须被装满，那么任何容量的背包 都有一个合法解“什么都不装”，这个解的价值为 0，所以初始时状态的值也就全部为 0 了。 