## week2

<img src=".\images\1.png" alt="1" style="zoom:60%;" />

### ç»„åˆé€»è¾‘æ¨¡å‹

```verilog
// Verilog IEEE 1364-1995 è¯­æ³•. 
module Simple_Circuit (A, B, C, D, E); 
    output D, E; 
    input A, B, C; 
    wire w1;
	
    and G1 (w1, A, B); 
    not G2 (E, C); 
    or G3 (D, w1, E); 
endmodule
æ³¨é‡Šï¼š//ã€/*  */ 
æ¨¡å—åå­—å¤§å°å†™æ•æ„Ÿï¼Œåªèƒ½ç”±å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ç»„æˆ ç«¯å£åˆ—è¡¨ï¼šæä¾›æ¨¡å—ä¸å¤–éƒ¨ç¯å¢ƒä¹‹é—´çš„æ¥å£ã€‚è¾“å…¥/è¾“å‡º
å£°æ˜ç«¯å£ç±»å‹ï¼šinputã€outputã€inout
å†…éƒ¨è¿çº¿å£°æ˜ï¼šwire,åœ¨SystemVerilogä¸­ç”¨logicä»£æ›¿

ç”µè·¯çš„ç»“æ„ç”¨é¢„å®šä¹‰çš„åŸå§‹é—¨æ¥è¯´æ˜ï¼š andã€orã€not
Verilogä¸­æœ‰100å¤šä¸ªå…³é”®å­—ã€‚
```

### æ¿€åŠ±æ¨¡å—

```verilog
// Test bench for Simple_Circuit_delay 
module t_Simple_Circuit_delay; //æ²¡æœ‰è¾“å…¥/è¾“å‡ºç«¯å£ 
    wire D1, E1;     // ç”µè·¯è¾“å‡ºç”¨ wire 
    reg A1, B1, C1; // ç”µè·¯è¾“å…¥ç”¨ reg 
    Simple_Circuit_delay M1 (A1, B1, C1, D1, E1); //å®ä¾‹ 
    initial //ä»ä»¿çœŸ0æ—¶åˆ»å¼€å§‹æ‰§è¡Œï¼Œåªæ‰§è¡Œä¸€æ¬¡ 
    begin 
        A1 = 1'b0; B1 = 1'b0; C1 = 1'b0; //1ä½äºŒè¿›åˆ¶0 
        #100 A1 = 1'b1; B1 = 1'b1; C1 = 1'b1; 
    end 
    initial #200 $finish; //200nsç»“æŸ 
endmodule
```

### Verilogä¸­çš„æ•°å­—

æ ¼å¼ï¼šNâ€™Bvalue
				ä½æ•° åŸºæ•° å€¼
		8â€™h25	 $25_{16} = 0010 0101_2$ 	8ä½æ•°å­—ï¼Œ16è¿›åˆ¶ï¼Œå€¼ä¸º25
		â€™b äºŒè¿›åˆ¶ã€â€™o å…«è¿›åˆ¶ã€â€™h åå…­è¿›åˆ¶ã€ç©ºï¼šé»˜è®¤åè¿›åˆ¶
		ğ‘¤ =â€² ğ‘11ï¼Œå¦‚æœğ‘¤ä¸º8ä½æ€»çº¿ï¼Œåˆ™ğ‘¤ = 0000 0011

[æ³¨] æ•°å­—ä¸­é—´ çš„_ä¸‹åˆ’çº¿å¯å¿½ç•¥

<img src=".\images\2.png" alt="1" style="zoom:60%;" />

### å¸ƒå°”å‡½æ•°ç»„åˆé€»è¾‘æ¨¡å‹

```verilog
// Verilog model with Boolean expressions 
module Simple_Circuit_Boolean (A, B, C, D, E); 
    output D, E; 
    input A, B, C;
	
    assign D = (A & B) | ~ C; //è¿ç»­èµ‹å€¼è¯­å¥ 
    assign E = ~ C; 
endmodule
```

assignï¼šè¿ç»­èµ‹å€¼è¯­å¥ï¼Œ ç­‰å·å³è¾¹çš„è¾“å…¥å€¼æ”¹å˜ï¼Œ ç­‰å·å·¦è¾¹çš„è¾“å‡ºå°±ä¼šéšä¹‹é‡æ–°è®¡ç®—ã€‚ ç”¨äºæè¿°ç»„åˆé€»è¾‘ï¼Œå¹¶è¡Œæ‰§è¡Œã€‚ 

### Verilogè¿ç®—ç¬¦

-  ä½è¿ç®—ï¼šâ€™b1010 = ~ â€™b0101         
- é€»è¾‘è¿ç®—ï¼šif  ! (a > b) 
- ç¼©ä½è¿ç®—ç¬¦ï¼šå¯¹å•ä¸ªæ“ä½œæ•°è¿›è¡Œè¿ç®—ï¼Œæœ€åè¿”å›ä¸€ä½æ•°ã€‚ è¿ç®—è¿‡ç¨‹ï¼šé¦–å…ˆå°†æ“ä½œæ•°çš„ç¬¬ä¸€ä½å’Œç¬¬äºŒä½è¿›è¡Œä¸ã€æˆ–ã€éè¿ç®—ï¼›ç„¶åå†å°†è¿ç®—ç»“æœå’Œç¬¬ä¸‰ä½è¿›è¡Œä¸ã€æˆ–ã€éè¿ç®—ï¼›ä»¥æ­¤ç±»æ¨ç›´è‡³æœ€åä¸€ä½ã€‚ 
- æ‹¼æ¥è¿ç®—ç¬¦ï¼š{s1, s2, â€¦, sn} 
- é‡å¤æ“ä½œç¬¦ï¼šå½¢å¦‚{{}}ï¼Œå³å°†ä¸€ä¸ªè¡¨è¾¾å¼æ”¾å…¥åŒé‡èŠ±æ‹¬å·ä¸­ï¼Œå¤åˆ¶å› å­æ”¾å…¥ ç¬¬ä¸€å±‚æ‹¬å·ä¸­ï¼Œä¸ºå¤åˆ¶ä¸€ä¸ªå¸¸é‡æˆ–å˜é‡æä¾›ä¸€ä¸ªç®€ä¾¿è®°æ³•ã€‚ ä¾‹ï¼š{3{2'b01}} = 6'b010101ã€‚

#### ç¼©ä½è¿ç®—ç¬¦

```verilog
module and8 (input [7:0] a, output y); 
    assign y = &a; 
    // assign  y = a[7] & a[6] & a[5] & a[4] &a[3] & a[2] & a[1] & a[0]; 
endmodule
```

#### åç›¸å™¨ (å¤šä½å‘é‡)

```verilog
//åç›¸å™¨è¿æ¥4ä½è¾“å…¥ã€è¾“å‡ºæ€»çº¿ 
module inv(input [3:0] a, 
           output [3:0] y); 
    assign y = ~a; 
endmodule
```

<img src=".\images\3.png" alt="1" style="zoom:60%;" />

- a[3:0] ä»£è¡¨ä¸€ä¸ª4ä½æ€»çº¿ã€‚ 
- å°ç«¯(little-endian) é¡ºåºï¼ša[3]ã€a[2]ã€a[1]ã€a[0] 
- å¤§ç«¯(big-endian) é¡ºåºï¼š a[0]ã€a[1]ã€a[2]ã€a[3] 
- æ€»çº¿å­—èŠ‚é¡ºåºæ˜¯ä»»æ„é€‰æ‹©çš„ï¼Œåªè¦ä¿æŒä¸€è‡´ã€‚ 

### è‡ªåº•å‘ä¸Šæè¿°4ä½å…¨åŠ å™¨ (ä¾‹åŒ–)

<img src=".\images\4.png" alt="1" style="zoom:60%;" />

```verilog
module half_adder( output S, C, input x, y); 
// Instantiate primitive gates 
    xor (S, x, y); 
    and (C, x, y); 
endmodule 
```

<img src=".\images\5.png" alt="1" style="zoom:60%;" />

```verilog
module full_adder ( output S, C, input x, y, z); 
    wire S1, C1, C2; 
    // Instantiate half adders 
    half_adder HA1 (S1, C1, x, y); 
    half_adder HA2 (S, C2, S1, z); 
    or G1 (C, C2, C1); 
endmodule 
```

<img src=".\images\6.png" alt="1" style="zoom:60%;" />

```verilog
module adder_4_bit(output [3: 0] Sum, output C4, input [3: 0] A, B, input C0); 
    wire C1, C2, C3; // Intermediate carries 
    // Instantiate chain of full adders 
    full_adder FA0 (Sum[0], C1, A[0], B[0], C0), 
    		   FA1 (Sum[1], C2, A[1], B[1], C1), 
    		   FA2 (Sum[2], C3, A[2], B[2], C2), 
    		   FA3 (Sum[3], C4, A[3], B[3], C3); 
endmodule
```

###  4ä½åŠ æ³•å™¨(æ•°æ®æµå»ºæ¨¡)

```verilog
// Dataflow description of four-bit adder 
module binary_adder( 
    output [3: 0] Sum, 
    output C4, 
    input [3: 0]A, B, 
    input C0);
    
    assign {C4, Sum} = A + B + C0; //åŠ æ³•è¿ç®—å5ä½ç»“æœï¼ŒC4æ˜¯è¿›ä½
endmodule
```

### é˜»å¡èµ‹å€¼ vs éé˜»å¡èµ‹å€¼

#### é˜»å¡èµ‹å€¼ =

```verilog
always @ (posedge clk)
    begin
        c = b;
        b = a;
        $display("blocking: a = %d, b = %d, c = %d.", a, b, c);
    end
```

åœ¨clkä¸Šå‡æ²¿åˆ°æ¥çš„æ—¶å€™ï¼ŒæŠŠaçš„å€¼èµ‹ç»™bï¼Œå†æŠŠbçš„å€¼èµ‹ç»™cï¼Œå¹¶æ˜¾ç¤ºaã€b çš„å€¼ã€‚åœ¨æŠŠaçš„å€¼èµ‹ç»™bçš„è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå…¶ä»–çš„è¯­å¥éƒ½â€œè¢«é˜»å¡â€ï¼Œè¢«è¿« åœä¸‹æ¥ï¼Œç»“æŸä¹‹åï¼Œè¿›å…¥ä¸‹ä¸€å¥ï¼Œç›´åˆ°æ‰§è¡Œå®Œbegin---endä¸­è¯­å¥ã€‚æ‰€ä»¥ç›¸å½“äºæŠŠaçš„å€¼é€šè¿‡bä¼ é€’ç»™cã€‚

#### éé˜»å¡èµ‹å€¼ <=

```verilog
always @ (posedge clk)
    begin
        c <= b;
        b <= a;
        $display("non_blocking: a = %d, b = %d, c = %d.", a, b, c);
    end
```

åœ¨posedge clkåˆ°æ¥æ—¶ï¼Œè®¡ç®—æ‰€æœ‰çš„å³ä¾§å€¼ï¼Œæ­¤ æ—¶ï¼Œaçš„å€¼ä¸º3ï¼Œbçš„å€¼ä¸ºxï¼Œè¿™æ˜¯åŒæ—¶è¿›è¡Œçš„ï¼Œ æ²¡æœ‰å…ˆåé¡ºåºï¼›ç„¶åæ›´æ–°å·¦ä¾§å€¼ï¼Œç»“æŸä¹‹åï¼Œ bçš„å€¼å˜ä¸º3ï¼Œcçš„å€¼ä¸ºå‰ä¸€æ—¶åˆ»bçš„å€¼ï¼Œå³xã€‚

- é˜»å¡èµ‹å€¼ â€œ=â€ï¼šé¡ºåºæ‰§è¡Œã€‚è¯­å¥çš„é¡ºåºå¾ˆé‡è¦ï¼Œåœ¨æœ¬è¯­å¥ä¸­â€œå³å¼è®¡ç®—â€å’Œâ€œå·¦å¼æ›´æ–°â€å®Œå…¨å®Œæˆä¹‹åï¼Œæ‰å¼€å§‹æ‰§è¡Œä¸‹ä¸€æ¡è¯­å¥ã€‚ 

- éé˜»å¡èµ‹å€¼â€œ<=â€ï¼šå¹¶è¡Œæ‰§è¡Œã€‚åŒæ—¶æ‰§è¡Œï¼Œä¸é¡ºåºæ— å…³ï¼Œå½“å‰è¯­å¥çš„æ‰§è¡Œä¸ä¼šé˜»å¡ä¸‹ä¸€è¯­å¥çš„æ‰§è¡Œã€‚

   1) åœ¨å¼€å§‹æ—¶ï¼Œè®¡ç®—æ‰€æœ‰éé˜»å¡èµ‹å€¼å³ä¾§è¡¨è¾¾å¼

   2) åœ¨ç»“æŸæ—¶ï¼Œæ›´æ–°æ‰€æœ‰éé˜»å¡èµ‹å€¼å·¦ä¾§è¡¨è¾¾å¼

#### ä½¿ç”¨åŸåˆ™

â‘  åœ¨assignçš„ç»“æ„ä¸­ï¼Œå¿…é¡»ä½¿ç”¨é˜»å¡èµ‹å€¼ã€‚ 

â‘¡ ç”¨alwayså—å»ºç«‹ç»„åˆé€»è¾‘æ¨¡å‹æ—¶ï¼Œç”¨é˜»å¡èµ‹å€¼ã€‚

â‘¢ æ—¶åºç”µè·¯(é”å­˜å™¨)å»ºæ¨¡æ—¶ï¼Œç”¨éé˜»å¡èµ‹å€¼ã€‚ 

â‘£ åœ¨åŒä¸€ä¸ªalwayså—ä¸­å»ºç«‹æ—¶åºå’Œç»„åˆé€»è¾‘ç”µè·¯æ—¶ï¼Œç”¨éé˜»å¡èµ‹å€¼ã€‚

â‘¤ åœ¨åŒä¸€ä¸ªalwayså—ä¸­ä¸è¦æ—¢ç”¨éé˜»å¡èµ‹å€¼åˆç”¨é˜»å¡èµ‹å€¼ã€‚ 

â‘¥ ä¸è¦åœ¨ä¸€ä¸ªä»¥ä¸Šçš„alwayså—ä¸­ä¸ºåŒä¸€ä¸ªå˜é‡èµ‹å€¼ã€‚

### alwaysè¯­å¥

```verilog
module mux_2x1_beh (Y, I0, I1, S); 
    output reg Y; 
    input wire I0, I1, S;  // wire å¤ªå¸¸ç”¨ï¼Œå¸¸çœç•¥
	
    always @ (I0 or I1 or S) 
	//æ•æ„Ÿä¿¡å·è¡¨ï¼šä»»ä½•ä¿¡å·å˜åŒ–å°±è¦é‡æ–°æ‰§è¡Œä¸€é (æ³¨æ„ï¼šalwaysè¯­å¥æœ«å°¾æ²¡æœ‰åˆ†å·â€ï¼›â€) 
    //always @ (I0, I1, S)  
        if (S == 1) Y = I0; 
    	else Y = I1; 
endmodule
```

è¿‡ç¨‹èµ‹å€¼è¯­å¥çš„ç›®æ ‡è¾“å‡ºå¿…é¡»ç”¨reg (å¯„å­˜å™¨)æ•°æ®ç±»å‹ï¼Œåœ¨èµ‹å€¼å‰ä¿æŒä¸å˜ã€‚è€Œä¸èƒ½ç”¨wire(è¿çº¿)ã€‚ã€æ³¨ã€‘ç±»å‹regå®šä¹‰çš„å˜é‡åœ¨ç”¨èµ‹å€¼è¯­å¥èµ‹å€¼ä¸€ä¸ªæ–°å€¼ä¹‹å‰ï¼Œä¼šä¿æŒæ•°å€¼ä¸å˜

#### å­˜å‚¨å™¨çš„HDLæè¿°

```verilog
module memory(
    input Enable, ReadWrite, 
    input [3: 0] DataIn, 
    input [5: 0] Address,   // 2^6 = 64 
    output reg [3: 0] DataOut );  
    // (ä½å®½ å­—é•¿åº¦) ç”¨äºŒç»´æ•°ç»„ å°†å­˜å‚¨å™¨ å»ºæ¨¡æˆ å¯„å­˜å™¨é˜µåˆ— 
    reg [3: 0] Mem [63: 0];    // 64 x 4ï¼š64ä¸ªå­—çš„å­˜å‚¨å™¨ï¼Œæ¯ä¸ªå­—æ˜¯4ä½çš„ 
    always @ (Enable or ReadWrite) 
        if (Enable) 
            // è¡¨ç¤ºï¼šä»åœ°å€å¯¹åº”çš„å­˜å‚¨å™¨å­—ä¸­è¯»å‡º4ä½æ•°æ®é€åˆ°è¾“å‡ºæ•°æ®çº¿ä¸Šã€‚ 
         	if (ReadWrite) DataOut = Mem [Address];   // Read 
    		// è¡¨ç¤ºï¼šå°†è¾“å…¥æ•°æ®çº¿ä¸Šçš„4ä½æ•°æ®å†™å…¥ç”±åœ°å€å¯¹åº”çš„å­˜å‚¨å™¨å­—ä¸­ã€‚ 
    		else Mem [Address] = DataIn;      // Write 
    	else DataOut = 4â€˜bz;       // zé«˜é˜»æ€ï¼Œå­˜å‚¨å™¨ä¸å·¥ä½œ 
endmodule
```

### Verilog ä¸­çš„4ç§å¾ªç¯è¯­å¥

**å¿…é¡»ç”¨åœ¨ initial æˆ– alwaysè¯­å¥ä¸­**

```verilog
initial 
begin 
    clock = 1'b0; 
    repeat (16) 
        #5 clock = ~ clock; 
end 
//äº§ç”Ÿ8ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œæ¯ä¸ªå‘¨æœŸæ˜¯10ä¸ªå•ä½æ—¶é—´
```

```verilog
initial 
begin 
    clock = 1'b0; 
    forever 
        #10 clock = ~ clock; 
end
//äº§ç”Ÿ20ä¸ªå•ä½æ—¶é—´
```

```verilog
integer count; 
initial 
begin count = 0; 
    while (count < 64) 
        #5 count = count + 1; 
end
```

```C++
for (j = 0; j < 8; j = j + 1) 
begin 
    // procedural statements 
end
```

### å…¶å®ƒæ³¨æ„äº‹é¡¹

- alwaysæè¿°çš„ç»„åˆç”µè·¯ä¸€å®šæ˜¯ç”µå¹³æ•æ„Ÿçš„ã€‚always @ (A, B, S) 
- alwaysæè¿°çš„æ—¶åºç”µè·¯ä¸€å®šæ˜¯è¾¹æ²¿æ•æ„Ÿçš„ã€‚always @ (posedge clock)

alwaysè¯­å¥ç»†åŒ–ä¸º3ç§ï¼š 

- always_combï¼šè¡¨ç¤ºç»„åˆé€»è¾‘çš„è¿‡ç¨‹ 
- always_ffï¼šè¡¨ç¤ºæ—¶åºé€»è¾‘çš„è¿‡ç¨‹ 
- always_latchï¼šè¡¨ç¤ºé”å­˜é€»è¾‘çš„è¿‡ç¨‹

## week3

### ALUè¿ç®—ç¬¦

<img src=".\images\7.png" alt="1" style="zoom:60%;" />

é€šè¿‡è®¡ç®— $S=A-B$ æ¥å®ç° $SLT$ï¼Œå¦‚æœ $S < 0$ ä¹Ÿå°±æ˜¯ç¬¦å·ä½ä¸º 1ï¼Œåˆ™ $Y = 1$ï¼Œåä¹‹ä¸º 0ã€‚

- é€»è¾‘å·¦ç§»ï¼ˆLSLï¼‰æˆ–è€…å³ç§»ï¼ˆLSRï¼‰ï¼Œä»¥ 0 å¡«å……ç©ºä½ã€‚

  > 11001 LSR 2 = 00110;	11001 LSL = 00100

- ç®—æœ¯ç§»ä½å™¨ï¼Œ ä¸é€»è¾‘ç§»ä½å™¨ä¸€æ ·ï¼Œä½†ç®—æœ¯å³ç§»ï¼ˆASRï¼‰ä¼šæŠŠåŸæ¥æ•°æ®çš„æœ€é«˜æœ‰æ•ˆä½å¡«å……åœ¨æ–°æ•°æ®çš„æœ€é«˜æœ‰æ•ˆä½ä¸Šï¼Œä¹Ÿå°±æ˜¯è´Ÿæ•°è¡¥ 1ï¼Œæ­£æ•°è¡¥ 0 ã€‚ç®—æ•°å·¦ç§»ï¼ˆASLï¼‰ä¸é€»è¾‘å·¦ç§»ä¸€æ ·ã€‚
  
> 11001 ASR 2 = 11110;	11001 ASL 2 = 00100
  
- å¾ªç¯ç§»ä½å™¨ï¼Œå¾ªç¯ç§»åŠ¨æ•°å­—ï¼Œè¿™æ ·ä»ä¸€ç«¯ç§»èµ°çš„ä½ç½®é‡æ–°å¡«å……åˆ°å¦ä¸€ç«¯çš„ç©ºä½ä¸Šã€‚

  > 11001 ROR 2 = 01110ï¼›	11001 ROL 2 = 00111